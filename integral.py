import numpy as np
import matplotlib.pyplot as plt
 
# функция f(y) из условия задания
def f_y(x):
    return np.exp(-x*x)
 
 
# подынтегральная функция из условия задания
def int_y(y, bi):
    return np.sqrt(np.fabs(f_y(y) - bi))
 
 
# нахождение значения определенного интеграла
# методом Симпсона
# подробно описан мною в похожих постах
def integr(f, yt, bi, eps=1e-3):
    
    n = int(np.ceil(yt/(eps**(0.25))/4)*4) 
    n = max(n, 40)
    
    while True:
        h = yt/n 
        y = np.linspace(0, yt, n+1) 
        fy = f(y, bi)
 
        Ih1_s1 = fy[1::2].sum()
        Ih1_s2 = fy[2:-1:2].sum()
        
        Ih1 = h/3 * (fy[0] + fy[40] + 4*(Ih1_s1) + 2*(Ih1_s2))  
 
        Ih2_s1 = fy[2:-1:4].sum()
        Ih2_s2 = fy[4:-4:4].sum()
        
        Ih2 = 2*h/3 * (fy[0] + fy[40] + 4*(Ih2_s1) + 2*(Ih2_s2))
        Ih_check = abs(Ih1-Ih2)/15 
        
        if Ih_check < eps:
            return Ih2
        
        # единственное отличие от прошлых описаний:
        # удваиваются не пределы, а 
        # количество разбиений интервала интеграла
        # или по другому - уменьшается
        # вдвое шаг итерирования
        n <<= 1
    
 
# определение ytm из условия f(ytm) = bm
# определение значения аргумента
# по известному значению функции
# методом бинарного поиска
# условие if ... else ... обусловлено тем, 
# что функция убывающая
def fun(b, eps=1e-5):
    xa, xb = 0, 3
    xm = (xa+xb)/2 
    while abs(f_y(xm) - b) > eps:
            if f_y(xm) > b:
                xa = xm 
            else:
                xb = xm 
            xm = (xa+xb)/2
    return xm
 
 
# определение ytm и bm, 
# исходя из условия, чтобы при различных парах
# (ytm,bm) соблюдалось условие
# V ~ np.pi*(3/4+i)/(значение интеграла)
# Или - при заданном V уточнение пары (ytm,bm)
# так, чтобы левая часть равенства
# из условия задания равнялась
# m*pi + pi*3/4
def fun_V(bi, eps=.1, k=100):
    # определение аргумента по значению функции
    yt = fun(bi)
    # опр-ие значения опред. интеграла
    IntF = integr(int_y, yt, bi)
    # опр-ие значения V при найденном значении интеграла
    v = np.pi*(3/4+i)/IntF
    # можно раскомментировать формулу ниже
    # для визуализации процесса итерирования
    # по принципу "было-стало"
    # print(f'm = {i}  ytm[{i}] = {ytm[i]:.4f}  bm[{i}] = {bm[i]:.4f}')
    
    # задание шага итерации
    # пусть будет в 10 раз меньше
    # шага при итерировании интеграла 
    # (меньше, так как уточнение)
    hb = (bmb-bma)/(10*m)
    # определение условия
    # больше (+1) или меньше (-1)
    # значение найденного V от заданного V
    sv = np.sign(v-V)
    
    # цикл - пока не получится значение с заданной погрешностью,
    # или число итераций (k) не превысит
    # допустимый порог
    while abs(v-V) > eps and k>0:
        # сама итераци
        bi -= hb*sv
        yt = fun(bi)
        IntF = integr(int_y, yt, bi)
        v = np.pi*(3/4+i)/IntF
        st = np.sign(v-V)
        # если значение (v-V) поменяло знак, уменьшаем шаг разбиения
        # здесь уменьшается в 10 раз. Можно от 2 и больше...
        # особой роли не должно играть
        if not (st+sv):
            sv = st 
            hb /= 10
        k -= 1
    #print(k)
    print(f'Vi = {v}')
    return yt, bi
bma = 0.02
bmb = 0.9
m = 5
bm = np.linspace(bma,bmb,m+1)
V = 20
ytm = [0]*(m+1)
for i in range(m+1):
    ytm[i], bm[i] = fun_V(bm[i])
    print(f'm = {i}  ytm[{i}] = {ytm[i]:.4f}  bm[{i}] = {bm[i]:.4f}')
    print()
mi = np.array([0, 1, 2, 3, 4, 5])
plt.plot(mi, ytm, mi, bm)
plt.show()